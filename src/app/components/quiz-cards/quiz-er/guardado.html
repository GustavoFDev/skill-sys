
onSliderChange(idx: number, event: Event): void {

    const inputElement = event.target as HTMLInputElement;
    const value = Number(inputElement.value);
  
    // Buscar qu칠 칤ndice de registro corresponde a este slider
    const registroIdx = this.ordenInterno.indexOf(idx + 1);
  
    console.log(Slider ${idx + 1} cambiado. Registro asociado: ${registroIdx + 1}, Valor: ${value});
  
    if (registroIdx >= 0 && registroIdx < this.sliderValuesOrdenado.length) {
      this.sliderValuesOrdenado[registroIdx] = value;
      this.sliderValuesChange.emit([...this.sliderValuesOrdenado]); 
    } else {
      console.warn(칈ndice fuera de rango: ${registroIdx});
    }
    
  }



  onSliderChange(idx: number, event: Event): void {
    const inputElement = event.target as HTMLInputElement;
    let value = Number(inputElement.value);
  
    // Buscar qu칠 칤ndice de registro corresponde a este slider
    const registroIdx = this.ordenInterno.indexOf(idx + 1);
  
    console.log(`Slider ${idx + 1} cambiado. Registro asociado: ${registroIdx + 1}, Valor: ${value}`);
  
    // Variables para almacenar valores corregidos
    let correctedValue = value;
  
    // Aplicar restricciones seg칰n el 칤ndice del slider
    if (idx === 0) { // Slider 1
        // 游댠 Slider 1 define el m치ximo global, pero no puede ser menor que el m칤nimo del Slider 2
        if (this.minValue !== undefined) {
            correctedValue = Math.max(value, this.sliderValuesOrdenado[1]); // Cambiado a slider 2
        }
        // 游 Nueva restricci칩n: No puede bajar m치s que el Slider 3
        if (this.sliderValuesOrdenado[2] !== undefined) {
            correctedValue = Math.max(correctedValue, this.sliderValuesOrdenado[2]); // No puede bajar m치s que el Slider 3
        }
        this.maxValue = correctedValue;
        console.log(`Nuevo m치ximo global: ${this.maxValue}`);
    } 
    else if (idx === 3) { // Slider 4
        // 游댠 Slider 4 define el m칤nimo global, pero no puede superar el m치ximo del Slider 3
        if (this.maxValue !== undefined) {
            correctedValue = Math.min(value, this.sliderValuesOrdenado[2]); // Cambiado a slider 3
        }
        // 游 Nueva restricci칩n: No puede subir m치s que el Slider 2
        if (this.sliderValuesOrdenado[1] !== undefined) {
            correctedValue = Math.min(correctedValue, this.sliderValuesOrdenado[1]); // No puede subir m치s que el Slider 2
        }
        this.minValue = correctedValue;
        console.log(`Nuevo m칤nimo global: ${this.minValue}`);
    } 
  
    // 游댠 游댠 游댠 PRIMERO aplicar los l칤mites a sliders intermedios
    if (idx === 1) { // Slider 2
        if (this.minValueS2 !== undefined) {
            correctedValue = Math.max(correctedValue, this.minValueS2); // No bajar del m칤nimo del Slider 3
        }
        this.maxValueS3 = correctedValue; // Slider 2 actualiza el m치ximo de Slider 3
        console.log(`M치ximo permitido para Slider 3: ${this.maxValueS3}`);
    } 
    else if (idx === 2) { // Slider 3
        if (this.maxValueS3 !== undefined) {
            correctedValue = Math.min(correctedValue, this.maxValueS3); // No subir del m치ximo del Slider 2
        }
        this.minValueS2 = correctedValue; // Slider 3 actualiza el m칤nimo de Slider 2
        console.log(`M칤nimo permitido para Slider 2: ${this.minValueS2}`);
    }
  
    // 游댠 Aplicar l칤mites globales despu칠s de los l칤mites espec칤ficos
    if (idx > 0 && idx < 3) {
        if (this.maxValue !== undefined) {
            correctedValue = Math.min(correctedValue, this.maxValue);
        }
        if (this.minValue !== undefined) {
            correctedValue = Math.max(correctedValue, this.minValue);
        }
    }
  
    // Si el valor fue corregido, actualizar el input para reflejarlo visualmente
    if (correctedValue !== value) {
        inputElement.value = correctedValue.toString();
    }
  
    // 游댠 Solo guardamos y emitimos si el valor realmente cambi칩 dentro de los l칤mites
    if (registroIdx >= 0 && registroIdx < this.sliderValuesOrdenado.length) {
        if (this.sliderValuesOrdenado[registroIdx] !== correctedValue) {
            this.sliderValuesOrdenado[registroIdx] = correctedValue;
            this.sliderValuesChange.emit([...this.sliderValuesOrdenado]); 
        }
    } else {
        console.warn(`칈ndice fuera de rango: ${registroIdx}`);
    }
}





  onSliderChange(idx: number, event: Event): void {
    const inputElement = event.target as HTMLInputElement;
    const value = Number(inputElement.value);

    // Buscar qu칠 칤ndice de registro corresponde a este slider
    const registroIdx = this.ordenInterno.indexOf(idx + 1);

    console.log(`Slider ${idx + 1} cambiado. Registro asociado: ${registroIdx + 1}, Valor: ${value}`);

    // Variables para almacenar valores corregidos sin afectar el original
    let localValue = value;
    let localMinValue = this.minValue; // Copia del m칤nimo global
    let localMaxValue = this.maxValue; // Copia del m치ximo global

    // Aplicar restricciones seg칰n el 칤ndice del slider
    if (idx === 0) {
        // Slider 1 define el m치ximo global, pero no puede ser menor que el m칤nimo global
        if (localMinValue !== undefined) {
            localValue = Math.max(value, localMinValue);
        }
        // No puede bajar m치s que el Slider 3
        if (this.sliderValuesOrdenado[2] !== undefined) {
            localValue = Math.max(localValue, this.sliderValuesOrdenado[2]);
        }
        localMaxValue = localValue; // Actualizamos el m치ximo local
        console.log(`Nuevo m치ximo global: ${localMaxValue}`);
    } else if (idx === 3) {
        // Slider 4 define el m칤nimo global, pero no puede superar el m치ximo global
        if (localMaxValue !== undefined) {
            localValue = Math.min(value, localMaxValue);
        }
        // No puede subir m치s que el Slider 2
        if (this.sliderValuesOrdenado[1] !== undefined) {
            localValue = Math.min(localValue, this.sliderValuesOrdenado[1]);
        }
        localMinValue = localValue; // Actualizamos el m칤nimo local
        console.log(`Nuevo m칤nimo global: ${localMinValue}`);
    }

    // Aplicar l칤mites a sliders intermedios
    if (idx === 1) { // Slider 2
        // No puede bajar del m칤nimo del Slider 3
        if (this.sliderValuesOrdenado[2] !== undefined) {
            localValue = Math.max(localValue, this.sliderValuesOrdenado[2]);
        }
        // No puede subir m치s que el m치ximo del Slider 1
        localValue = Math.min(localValue, localMaxValue);
        this.maxValueS3 = localValue; // Actualiza el m치ximo de Slider 3
        console.log(`M치ximo permitido para Slider 3: ${this.maxValueS3}`);
    } else if (idx === 2) { // Slider 3
        // No puede subir del m치ximo del Slider 2
        if (this.sliderValuesOrdenado[1] !== undefined) {
            localValue = Math.min(localValue, this.sliderValuesOrdenado[1]);
        }
        // No puede bajar m치s que el m칤nimo del Slider 4
        if (localMinValue !== undefined) {
            localValue = Math.max(localValue, localMinValue);
        }
        this.minValueS2 = localValue; // Actualiza el m칤nimo de Slider 2
        console.log(`M칤nimo permitido para Slider 2: ${this.minValueS2}`);
    }

    // Aplicar l칤mites globales despu칠s de los l칤mites espec칤ficos
    if (idx > 0 && idx < 3) {
        if (localMaxValue !== undefined) {
            localValue = Math.min(localValue, localMaxValue);
        }
        if (localMinValue !== undefined) {
            localValue = Math.max(localValue, localMinValue);
        }
    }

    // Si el valor fue corregido, actualizar el input para reflejarlo visualmente
    if (localValue !== value) {
        inputElement.value = localValue.toString();
    }

    // Guardar el valor en la lista original sin afectar el funcionamiento
    if (registroIdx >= 0 && registroIdx < this.sliderValuesOrdenado.length) {
        if (this.sliderValuesOrdenado[registroIdx] !== localValue) {
            this.sliderValuesOrdenado[registroIdx] = localValue;
            this.sliderValuesChange.emit([...this.sliderValuesOrdenado]); 
        }
    } else {
        console.warn(`칈ndice fuera de rango: ${registroIdx}`);
    }
}


